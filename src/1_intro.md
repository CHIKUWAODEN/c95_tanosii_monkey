前説
======
{: .counting }

何をつくるのか
--------
{: .counting }

　いきなりですが、時間も紙幅もかぎられているため、飛ばしていきましょう。
さて、今回目指すのは、クラスの簡単な実装です。
具体的には、次ようなソースコードを解釈できるように Monkey を改造することです。

    class Foo
    {
      let myName = "bar";
      let constructor = fn(name) {
        this.myName = name;
      };
    };

    let foo = Foo("Jhon doe"); 
    foo.myName;


　このコードをインタプリタで実行したときに想定される結果は次のとおりです。
ちょっと見た目が汚いのは、Monkey インタプリタにはファイルを入力したり改行（Enter の入力）をまたいで言語をうまく処理できないことによります。
一行で全てのソースを記述している、という風に読み書きしてくれればと思います。


<pre><code>
Hello kandayasu! This is Monkey programming language!
Feel free to type in commands.
>> class Foo { let myName = "bar"; let constructor = fn(name) { this.myName = name; }; }; let foo = Foo("Jhon doe"); foo.myName; [ENTER]
Jhon doe
</code></pre>


　見た目はわりとよくありそうな感じですね。
オリジナルの Monkey と比較してみると、このコードには次のような特徴があります（これから改造するので、当然ながら元のままの Monkey インタプリタでは動作できません）。


- `class <クラス名> {...}` としてクラスを定義することができる
- クラスの中で let を使うと、そのクラスのインスタンスメンバ変数や関数として振る舞う
- `this . <メンバ名>` で、インスタンスメソッド中でメンバを参照することができる
- `this.myName = name;` のように、代入操作ができる（Monkey には代入がない）
- `<クラス名>()` のように、クラス名に関数呼び出し演算子を適用することでインスタンスを生成する関数となる
- `constructor` というメンバ関数を定義しておくと、その関数がコンストラクタとして呼ばれる


　やっていることは実にシンプルです。
クラスを一つかいて、コンストラクタが呼び出されることを確認、メンバ変数を設定したり値として評価する、というだけですね。ですが、いざ自分でその機能を書こうとするとやることがそこそこありますね。


やるべきことのおさらい
--------
{: .counting }

　具体的な作業手順として、次ような流れで進めていきます。

- 字句解析器（lexer）のまわり修正
  - .（ドット）トークンへの対応
  - class キーワードトークンへの対応
  - this キーワードトークンへの対応
- 構文解析器（parser）の修正
  - 演算子の優先順位テーブルの修正
  - 各種 ast.ノードクラスの追加
  - 各種パーサ関数の追加
- 評価器（evaluator）の修正
  - クラス定義
  - コンストラクタ
  - ドット演算子の評価
  - 代入演算子の評価
- 動作確認

　元本では、テストファーストのアプローチでまずはテストコードを書き、仕様としながらそれに合わせるように実装を重ねていくスタイルでした。
これを踏襲できればよかったのですが、ある程度 Monkey のソースについて知っているであろう前提で、
同じアプローチはとっていません。
本誌では今回のネタに合わせた部分しか掲載していませんが、一応テストコードも含め作成したコードは全て https://github.com/CHIKUWAODEN/monkey-for-c95 として公開しています。
ぜひ元本と合わせてコードをご覧になりながらお読みくださればと思います。
